- #CS
- = [[B+ Trees]]
-
- Properties
	- $M - 1$ keys
	- $L$ data items per leaf node
- Formulae
	- Minimum Numbers
		- Pointers (children) in root node: $2$
		- Pointers (children) in internal nodes: $\lceil \frac{M}{2} \rceil^{h - 1}$
		- Pointers (children) in leaf nodes: $\lceil \frac{L}{2} \rceil$
		-
		- Leaf nodes: $2 \cdot \lceil \frac{M}{2} \rceil^{h - 1}$
		- Data items: $2 \cdot \lceil \frac{M}{2} \rceil^{h - 1} \cdot \lceil \frac{L}{2} \rceil$
	- Maximum Numbers
		- Pointers (children) in root node: $M$
		- Pointers (children) in internal nodes: $M^{h - 1}$
		- Pointers (children) in leaf nodes: $L$
		-
		- Leaf nodes: $M^h$ ($= M \cdot M^{h - 1}$)
		- Data items: $M^h \cdot L$
	- The likely size of a page (a.k.a. a disk block)
		- Page Size: $P$ bytes
		- Key Size: $K$ bytes
		- Pointer Size: $Ptr$ bytes
		- Data Size: $D$ bytes per record (***includes*** the key)
		-
		- For an interior node: $K \cdot (M - 1) + Ptr \cdot M \le P$
			- => Let $I$
		- For a leaf node: $D \cdot L \le P$
			- => Let $N$
		- $max(I, N) \implies 2^k$ (to the closest $2^k$)
		-
		- e.g.
			- Suppose $M = 21$, $L = 12$, $K = 4$, $Ptr = 8$, and $D = 20$.
			- Then, $4 \cdot (21 - 1) + 8 \cdot 21 \le P$, $80 + 168 = 248$, so at least 248 bytes needed for an interior node.
			- For a leaf node, at least $20 \cdot 12 = 240$ bytes needed.
			- The page would need to be at least $max(248, 240) = 248$ bytes.
			- The next highest power of $2$ is $256$.
			- Therefore, $256$ bytes is the likely page size.
- Time Complexity
	- Insertion
		- [[Binary Search]] to find the correct leaf node: $O(\log_2{M} \cdot \log_M{N})$
			- [[Binary Search]]: $O(\log_2{M})$
			- Number of Levels: $O(\log_M{N})$
		- [[Binary Search]] in leaf: $O(\log_2{L})$
		- Insert (shift) data in leaf: $O(L)$
		- Split leaf: $O(L)$
		- Split pointers in parents, all the way up to root: $O(M \cdot \log_M{N})$
			- Split pointers in interior node: $O(M)$
			- Number of Levels: $O(\log_M{N})$
		- => $O(\log_2{M} \cdot \log_M{N} + \log_2{L} + L + L + M \cdot \log_M{N})$
		- => $O(L + M \cdot \log_M{N})$
		- Best Case
			- [[Binary Search]] to find the correct leaf node: $O(\log_2{M} \cdot \log_M{N})$
			- [[Binary Search]] in leaf: $O(\log_2{L})$
			- Insert (shift) data in leaf: $O(1)$
			- No Splits needed
			- => $O(\log_2{L} + M \cdot \log_M{N})$
	- Deletion
		- [[Binary Search]] to find the correct leaf node: $O(\log_2{M} \cdot \log_M{N})$
		- [[Binary Search]] and remove (shift data) in leaf: $O(\log_2{L} + L)$
		- Merge with neighbor leaf: $O(L)$
		- Merge all the way up to root: $O(M \cdot \log_M{N})$
		- => $O(L + M \cdot \log_M{N})$